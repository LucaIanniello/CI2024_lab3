# CI2024_lab2
# n^2 -1 Puzzle Problem

This repository contains the solution to the n puzzle problem implemented in the Jupyter Notebook `n-puzzle.ipynb` by the student Luca Ianniello, s327313.

## Algorithm Explanation

### A* Search Algorithm
The A* algorithm is a pathfinding algorithm that uses both the path cost (number of moves) and a heuristic (Manhattan distance) to guide the search toward the goal state efficiently.

#### Initialization:
- The initial puzzle state is added to the open list with a cost based on its Manhattan distance.

#### Exploring Nodes:
- The algorithm selects the state with the lowest total estimated cost (moves made + Manhattan distance).
- It then generates possible moves (neighbors) from the current state by sliding tiles into the empty space.

#### Heuristic - Manhattan Distance:
- The heuristic is calculated by summing the horizontal and vertical distances of each tile from its goal position.
- This helps prioritize states that are closer to the solved configuration, reducing the number of nodes expanded.
- It is also used the linear conflict to simply the process.

#### Goal Test:
- When the algorithm finds the goal state, it returns the solution path (sequence of moves), the quality of the solution (number of moves), and the cost (total nodes evaluated).

#### Why Use Manhattan Distance?
Manhattan distance is **admissible**, meaning it never overestimates the number of moves to the goal. This ensures that A* will find the shortest solution path. It provides a good balance of **computational efficiency** and **accuracy**.

#### Features

- **Efficient Solving of Custom Puzzle Sizes**: Easily change the puzzle dimension (e.g., 3x3, 4x4, 5x5).
- **Quality and Cost Tracking**: Outputs the number of moves and the total nodes evaluated, allowing analysis of solution efficiency.
- **Random Initial State**: The puzzle can be randomized using `RANDOMIZE_STEPS`, a parameter controlling the number of random moves applied from the solved state.

#### Results
This algorithm resolves efficiently the 3x3 matrix, but for greater values it can take too much time. A 4x4 was obtained after 25 minutes and this is not optimal for our task.

### Beam Search Algorithm
Beam Search is a heuristic-guided search algorithm that explores the most promising states at each level while discarding others. It balances computational efficiency with solution quality by limiting the number of states explored at each depth using a fixed **beam size**.

#### Initialization  
- The initial puzzle state is added to a priority queue with its priority calculated using a heuristic.  
- The **heuristic** combines:
  - **Manhattan Distance**: Estimates the number of moves required to reach the goal state.
  - **Difference from Goal**: Counts the number of tiles out of place.  

#### Exploring Nodes  
- At each step, the algorithm selects the top `beam_size` states with the lowest heuristic values.  
- From these states, possible moves are generated by sliding tiles into the empty space.  

#### Heuristic - Combined Priority  
The priority for each state is calculated as: priority = 0.8 * difference_from_goal + 0.2 * manhattan_distance This ensures that states closer to the goal are prioritized.  

#### Goal Test  
- The algorithm stops as soon as the goal state is reached.  
- If the search space is exhausted without finding the goal, the algorithm terminates.

#### Why Use Beam Search?  

Beam Search is ideal for solving n-puzzles when **speed** and **reduced memory usage** are priorities. Unlike A*, Beam Search prunes less promising paths, significantly reducing the number of nodes expanded. However, it sacrifices optimality for efficiency.

#### Results
Thanks to Beam Search, the 3x3 and 4x4 puzzle is solved in less than a minute with quite good cost. Sometimes the correct path cannot be guaranteed, but in this case we focus mainly on speed. The 5x5 puzzle is solved in less than 3 minutes

